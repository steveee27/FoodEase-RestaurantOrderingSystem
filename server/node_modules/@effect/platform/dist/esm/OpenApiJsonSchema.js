/**
 * @since 1.0.0
 */
import * as Arr from "effect/Array";
import * as Option from "effect/Option";
import * as Predicate from "effect/Predicate";
import * as Record from "effect/Record";
import * as AST from "effect/SchemaAST";
/**
 * @category encoding
 * @since 1.0.0
 */
export const make = schema => {
  const $defs = {};
  const out = makeWithDefs(schema, {
    defs: $defs
  });
  if (!Record.isEmptyRecord($defs)) {
    out.$defs = $defs;
  }
  return out;
};
/**
 * @category encoding
 * @since 1.0.0
 */
export const makeWithDefs = (schema, options) => {
  const defsPath = options.defsPath ?? "#/$defs/";
  const getRef = id => `${defsPath}${id}`;
  const out = go(schema.ast, options.defs, true, [], {
    getRef
  });
  for (const id in options.defs) {
    if (options.defs[id]["$ref"] === getRef(id)) {
      delete options.defs[id];
    }
  }
  return out;
};
const constAny = {
  $id: "/schemas/any"
};
const constUnknown = {
  $id: "/schemas/unknown"
};
const constVoid = {
  $id: "/schemas/void"
};
const constAnyObject = {
  "$id": "/schemas/object",
  "anyOf": [{
    "type": "object"
  }, {
    "type": "array"
  }]
};
const constEmpty = {
  "$id": "/schemas/{}",
  "anyOf": [{
    "type": "object"
  }, {
    "type": "array"
  }]
};
const getJsonSchemaAnnotations = annotated => Record.getSomes({
  description: AST.getDescriptionAnnotation(annotated),
  title: AST.getTitleAnnotation(annotated),
  examples: AST.getExamplesAnnotation(annotated),
  default: AST.getDefaultAnnotation(annotated)
});
const removeDefaultJsonSchemaAnnotations = (jsonSchemaAnnotations, ast) => {
  if (jsonSchemaAnnotations["title"] === ast.annotations[AST.TitleAnnotationId]) {
    delete jsonSchemaAnnotations["title"];
  }
  if (jsonSchemaAnnotations["description"] === ast.annotations[AST.DescriptionAnnotationId]) {
    delete jsonSchemaAnnotations["description"];
  }
  return jsonSchemaAnnotations;
};
const getASTJsonSchemaAnnotations = ast => {
  const jsonSchemaAnnotations = getJsonSchemaAnnotations(ast);
  switch (ast._tag) {
    case "StringKeyword":
      return removeDefaultJsonSchemaAnnotations(jsonSchemaAnnotations, AST.stringKeyword);
    case "NumberKeyword":
      return removeDefaultJsonSchemaAnnotations(jsonSchemaAnnotations, AST.numberKeyword);
    case "BooleanKeyword":
      return removeDefaultJsonSchemaAnnotations(jsonSchemaAnnotations, AST.booleanKeyword);
    default:
      return jsonSchemaAnnotations;
  }
};
const pruneUndefinedKeyword = ps => {
  const type = ps.type;
  if (AST.isUnion(type) && Option.isNone(AST.getJSONSchemaAnnotation(type))) {
    const types = type.types.filter(type => !AST.isUndefinedKeyword(type));
    if (types.length < type.types.length) {
      return AST.Union.make(types, type.annotations);
    }
  }
};
const getRefinementInnerTransformation = ast => {
  switch (ast.from._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getRefinementInnerTransformation(ast.from);
    case "Suspend":
      {
        const from = ast.from.f();
        if (AST.isRefinement(from)) {
          return getRefinementInnerTransformation(from);
        }
      }
  }
};
const isParseJsonTransformation = ast => ast._tag === "Transformation" && ast.from.annotations[AST.SchemaIdAnnotationId] === AST.ParseJsonSchemaId;
const isOverrideAnnotation = jsonSchema => {
  return "type" in jsonSchema || "oneOf" in jsonSchema || "anyOf" in jsonSchema || "const" in jsonSchema || "enum" in jsonSchema || "$ref" in jsonSchema;
};
const go = (ast, $defs, handleIdentifier, path, options) => {
  const hook = AST.getJSONSchemaAnnotation(ast);
  if (Option.isSome(hook)) {
    const handler = hook.value;
    if (AST.isRefinement(ast)) {
      const t = getRefinementInnerTransformation(ast);
      if (t === undefined) {
        try {
          return {
            ...go(ast.from, $defs, true, path, options),
            ...getJsonSchemaAnnotations(ast),
            ...handler
          };
        } catch (e) {
          return {
            ...getJsonSchemaAnnotations(ast),
            ...handler
          };
        }
      } else if (!isOverrideAnnotation(handler)) {
        return {
          ...go(t, $defs, true, path, options),
          ...getJsonSchemaAnnotations(ast)
        };
      }
    }
    return handler;
  }
  const surrogate = AST.getSurrogateAnnotation(ast);
  if (handleIdentifier && !AST.isRefinement(ast)) {
    const identifier = AST.getJSONIdentifier(Option.isSome(surrogate) ? {
      annotations: {
        ...(ast._tag === "Transformation" ? ast.to.annotations : {}),
        ...ast.annotations
      }
    } : ast);
    if (Option.isSome(identifier)) {
      const id = identifier.value;
      const out = {
        $ref: options.getRef(id)
      };
      if (!Record.has($defs, id)) {
        $defs[id] = out;
        $defs[id] = go(ast, $defs, false, path, options);
      }
      return out;
    }
  }
  if (Option.isSome(surrogate)) {
    return {
      ...go(surrogate.value, $defs, handleIdentifier, path, options),
      ...(ast._tag === "Transformation" ? getJsonSchemaAnnotations(ast.to) : {}),
      ...getJsonSchemaAnnotations(ast)
    };
  }
  switch (ast._tag) {
    case "Declaration":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "Literal":
      {
        const literal = ast.literal;
        if (literal === null) {
          return {
            enum: [null],
            ...getJsonSchemaAnnotations(ast)
          };
        } else if (Predicate.isString(literal) || Predicate.isNumber(literal) || Predicate.isBoolean(literal)) {
          return {
            enum: [literal],
            ...getJsonSchemaAnnotations(ast)
          };
        }
        throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
      }
    case "UniqueSymbol":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "UndefinedKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "VoidKeyword":
      return {
        ...constVoid,
        ...getJsonSchemaAnnotations(ast)
      };
    case "NeverKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "UnknownKeyword":
      return {
        ...constUnknown,
        ...getJsonSchemaAnnotations(ast)
      };
    case "AnyKeyword":
      return {
        ...constAny,
        ...getJsonSchemaAnnotations(ast)
      };
    case "ObjectKeyword":
      return {
        ...constAnyObject,
        ...getJsonSchemaAnnotations(ast)
      };
    case "StringKeyword":
      return {
        type: "string",
        ...getASTJsonSchemaAnnotations(ast)
      };
    case "NumberKeyword":
      return {
        type: "number",
        ...getASTJsonSchemaAnnotations(ast)
      };
    case "BooleanKeyword":
      return {
        type: "boolean",
        ...getASTJsonSchemaAnnotations(ast)
      };
    case "BigIntKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "SymbolKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "TupleType":
      {
        const elements = ast.elements.map((e, i) => ({
          ...go(e.type, $defs, true, path.concat(i), options),
          ...getJsonSchemaAnnotations(e)
        }));
        const rest = ast.rest.map(annotatedAST => ({
          ...go(annotatedAST.type, $defs, true, path, options),
          ...getJsonSchemaAnnotations(annotatedAST)
        }));
        const output = {
          type: "array"
        };
        // ---------------------------------------------
        // handle elements
        // ---------------------------------------------
        const len = ast.elements.length;
        if (len > 0) {
          output.minItems = len - ast.elements.filter(element => element.isOptional).length;
          output.items = elements;
        }
        // ---------------------------------------------
        // handle rest element
        // ---------------------------------------------
        const restLength = rest.length;
        if (restLength > 0) {
          const head = rest[0];
          const isHomogeneous = restLength === 1 && ast.elements.every(e => e.type === ast.rest[0].type);
          if (isHomogeneous) {
            output.items = head;
          } else {
            output.additionalItems = head;
          }
          // ---------------------------------------------
          // handle post rest elements
          // ---------------------------------------------
          if (restLength > 1) {
            throw new Error(getJSONSchemaUnsupportedPostRestElementsErrorMessage(path));
          }
        } else {
          if (len > 0) {
            output.additionalItems = false;
          } else {
            output.maxItems = 0;
          }
        }
        return {
          ...output,
          ...getJsonSchemaAnnotations(ast)
        };
      }
    case "TypeLiteral":
      {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          return {
            ...constEmpty,
            ...getJsonSchemaAnnotations(ast)
          };
        }
        let patternProperties = undefined;
        let propertyNames = undefined;
        for (const is of ast.indexSignatures) {
          const parameter = is.parameter;
          switch (parameter._tag) {
            case "StringKeyword":
              {
                patternProperties = go(is.type, $defs, true, path, options);
                break;
              }
            case "TemplateLiteral":
              {
                patternProperties = go(is.type, $defs, true, path, options);
                propertyNames = {
                  type: "string",
                  pattern: AST.getTemplateLiteralRegExp(parameter).source
                };
                break;
              }
            case "Refinement":
              {
                patternProperties = go(is.type, $defs, true, path, options);
                propertyNames = go(parameter, $defs, true, path, options);
                break;
              }
            case "SymbolKeyword":
              throw new Error(getJSONSchemaUnsupportedParameterErrorMessage(path, parameter));
          }
        }
        const output = {
          type: "object",
          required: [],
          properties: {},
          additionalProperties: false
        };
        // ---------------------------------------------
        // handle property signatures
        // ---------------------------------------------
        for (let i = 0; i < ast.propertySignatures.length; i++) {
          const ps = ast.propertySignatures[i];
          const name = ps.name;
          if (Predicate.isString(name)) {
            const pruned = pruneUndefinedKeyword(ps);
            output.properties[name] = {
              ...go(pruned ? pruned : ps.type, $defs, true, path.concat(ps.name), options),
              ...getJsonSchemaAnnotations(ps)
            };
            // ---------------------------------------------
            // handle optional property signatures
            // ---------------------------------------------
            if (!ps.isOptional && pruned === undefined) {
              output.required.push(name);
            }
          } else {
            throw new Error(getJSONSchemaUnsupportedKeyErrorMessage(name, path));
          }
        }
        // ---------------------------------------------
        // handle index signatures
        // ---------------------------------------------
        if (patternProperties !== undefined) {
          delete output.additionalProperties;
          output.patternProperties = {
            "": patternProperties
          };
        }
        if (propertyNames !== undefined) {
          output.propertyNames = propertyNames;
        }
        return {
          ...output,
          ...getJsonSchemaAnnotations(ast)
        };
      }
    case "Union":
      {
        const enums = [];
        const anyOf = [];
        for (const type of ast.types) {
          const schema = go(type, $defs, true, path, options);
          if ("enum" in schema) {
            if (Object.keys(schema).length > 1) {
              anyOf.push(schema);
            } else {
              for (const e of schema.enum) {
                enums.push(e);
              }
            }
          } else {
            anyOf.push(schema);
          }
        }
        if (anyOf.length === 0) {
          return {
            enum: enums,
            ...getJsonSchemaAnnotations(ast)
          };
        } else {
          if (enums.length >= 1) {
            anyOf.push({
              enum: enums
            });
          }
          return {
            anyOf,
            ...getJsonSchemaAnnotations(ast)
          };
        }
      }
    case "Enums":
      {
        return {
          $comment: "/schemas/enums",
          anyOf: ast.enums.map(e => ({
            title: e[0],
            enum: [e[1]]
          })),
          ...getJsonSchemaAnnotations(ast)
        };
      }
    case "Refinement":
      {
        if (AST.encodedBoundAST(ast) === ast) {
          throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
        }
        return go(ast.from, $defs, true, path, options);
      }
    case "TemplateLiteral":
      {
        const regex = AST.getTemplateLiteralRegExp(ast);
        return {
          type: "string",
          description: "a template literal",
          pattern: regex.source,
          ...getJsonSchemaAnnotations(ast)
        };
      }
    case "Suspend":
      {
        const identifier = Option.orElse(AST.getJSONIdentifier(ast), () => AST.getJSONIdentifier(ast.f()));
        if (Option.isNone(identifier)) {
          throw new Error(getJSONSchemaMissingIdentifierAnnotationErrorMessage(path, ast));
        }
        return {
          ...go(ast.f(), $defs, true, path, options),
          ...getJsonSchemaAnnotations(ast)
        };
      }
    case "Transformation":
      {
        // Properly handle S.parseJson transformations by focusing on
        // the 'to' side of the AST. This approach prevents the generation of useless schemas
        // derived from the 'from' side (type: string), ensuring the output matches the intended
        // complex schema type.
        if (isParseJsonTransformation(ast)) {
          return {
            type: "string",
            contentMediaType: "application/json",
            contentSchema: go(ast.to, $defs, true, path, options),
            ...getJsonSchemaAnnotations(ast)
          };
        }
        return {
          ...getASTJsonSchemaAnnotations(ast.to),
          ...go(ast.from, $defs, true, path, options),
          ...getJsonSchemaAnnotations(ast)
        };
      }
  }
};
const getJSONSchemaMissingAnnotationErrorMessage = (path, ast) => getMissingAnnotationErrorMessage(`Generating a JSON Schema for this schema requires a "jsonSchema" annotation`, path, ast);
const getJSONSchemaMissingIdentifierAnnotationErrorMessage = (path, ast) => getMissingAnnotationErrorMessage(`Generating a JSON Schema for this schema requires an "identifier" annotation`, path, ast);
const getJSONSchemaUnsupportedParameterErrorMessage = (path, parameter) => getErrorMessage("Unsupported index signature parameter", undefined, path, parameter);
const getJSONSchemaUnsupportedPostRestElementsErrorMessage = path => getErrorMessage("Generating a JSON Schema for post-rest elements is not currently supported. You're welcome to contribute by submitting a Pull Request", undefined, path);
const getJSONSchemaUnsupportedKeyErrorMessage = (key, path) => getErrorMessage("Unsupported key", `Cannot encode ${formatPropertyKey(key)} key to JSON Schema`, path);
const getMissingAnnotationErrorMessage = (details, path, ast) => getErrorMessage("Missing annotation", details, path, ast);
const getErrorMessage = (reason, details, path, ast) => {
  let out = reason;
  if (path && Arr.isNonEmptyReadonlyArray(path)) {
    out += `\nat path: ${formatPath(path)}`;
  }
  if (details !== undefined) {
    out += `\ndetails: ${details}`;
  }
  if (ast) {
    out += `\nschema (${ast._tag}): ${ast}`;
  }
  return out;
};
const formatPathKey = key => `[${formatPropertyKey(key)}]`;
const formatPath = path => isNonEmpty(path) ? path.map(formatPathKey).join("") : formatPathKey(path);
const isNonEmpty = x => Array.isArray(x);
const formatPropertyKey = name => typeof name === "string" ? JSON.stringify(name) : String(name);
//# sourceMappingURL=OpenApiJsonSchema.js.map